# 요구사항 확인

## 애자일 방법론

- 작업 계획을 짧은 단위로 세우고 시제품을 만들어 나가는 사이클을 반복해서 고객 요구가 변해도 유연하고 신속하게 대응하는 방법론이다.
- 반대되는 방법론은 '폭포수 방법론'이 있다.

## GoF(Gang for Four)의 디자인 패턴

- 개념 : 23가지 디자인 패턴을 3가지 분류로 정리한 디자인 패턴이다.

### 1. 생성패턴(Creational Pattern)

- 추상 팩토리 (Abstract Factory)
  - 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴이다.
- 빌더 (Builder)
  - 복잡한 객체를 생성하는 클래스와 표현하는 클래스를 분리해서 동일 절차에서도 서로 다른 표현을 생성하는 패턴
- 팩토리 메서드 (Factory Method)
  - **상위 클래스 객체를 생성하는 인터페이스를 정의하며 하위 클래스에서는 인스턴스를 생성한다.**
- 프로토타입 (Prototype)
  - **기존 객체를 복제함으로써 객체를 생성한다.**
- 싱글톤 (Singleton) - **한 클래스에 한 객체만 존재하도록 제한한다.**

### 2. 구조 패턴 (Structural Pattern)

클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴

- 어댑터 (Adapter)
  - **인터페이스가 호환되지 않는 클래스들을 함께 이용하여 타 클래스의 인터페이스를 기존 인터페이스에 덧씌운다.**
- 브리지 (Bridege)
  - **구현부에서 추상층을 분리하여 각자 독립적 확장이 가능하다.**
- 컴포지트 (Composite)
  - **부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴이다.**
- 데코레이터 (Decorator)
  - 기존 객체의 메서드에 새로운 행동을 추가하거나 오버라이드 할 수 있다.
- 퍼싸드 (Facade)
  - 단순화된 하나의 인터페이스로 제공하는 패턴
- 플라이웨이트 (Flyweight
  - 공유를 통하여 많은 유사한 객체들을 효과적으로 지원하는 패턴
- 프록시 (Proxy)
  - 객체의 대리자를 이용하여 원래 객체의 작업을 대신 처리하는 패턴

### 3. 행위 패턴 (Behavioral Pattern)

클래스나 객체들이 서로 상호작용하는 방법이나 책임분배방법을 정의하는 패턴이다.

- 책임연쇄 (Chain of Responsibility)
  - 객체들끼리 연결 고리를 만들어 내부적으로 전달하는 패턴
- 커맨드 (Command)
  - 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴이다.
- 인터프리터 (Interpreter)
  - 사용자가 표현하기 쉬운 표현을 사용하게 하고 이를 해석하는 개체를 통해 약속된 알고리즘을 수행하는 패턴
- 반복자 (Iterator)
  - 하나씩 지정해서 순서대로 처리하는 패턴
- 중재자 (Mediator)
  - 객체 상호 작용(interface)을 캡슐화한 패턴
- 메멘토 (Memento)
  - 객체의 상태 값을 미리 저장해 두었다가 복구하는 패턴
- 옵서버 (Observer)
  - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고 자동으로 내용이 갱신되는 패턴
- 상태 (State)
  - 객체가 갖은 내부 상태에 따라 스스로 행동을 변경할 수 있게 하는 패턴
- 전략 (Strategy)
  - 다양한 알고리즘을 캡슐화하여 알고리즘을 교환하여 사용가능하도록 한 패턴
- 템플릿 메소드 (Template Method)
  - 상위 클래스에서는 추상적으로 표현하고, 그 구체적인 내용은 하위 클래스에서 결정되는 디자인 패턴
- 방문자 (Visitor)
  - 객체의 구조와 처리 기능을 분리시키는 패턴. 서로 다른 클래스로 분리한다.

<hr/>

## 2. UML (Unified Modeling Language)

- 개발자들이 원활한 의사소통을 하기 위해 고안된 표준 통합 모델링 언어이다.

### 1. 구조 다이어그램

- 클래스 다이어그램
  - 공통의 속성과 책임을 갖는 개체들의 집합, 각 개체들이 가지는 속성과 메서드를 포함하는 다이어그램이다.
- 객체 다이어그램
  - 객체와 객체 사이의 관계로 나타낸다.
- 컴포넌트 다이어그램
  - 시스템을 구성하는 컴포넌트 사이의 의존관계를 나타낸다.
- 배치 다이어그램
  - 결과물, 프로세스, 컴포넌트 등 물리적요소들의 위치를 나타낸다.
- 복합체 구조 다이어그램
  - 클래스나 컴포넌트가 복합구조를 갖는 경우 그 내부 구조를 나타낸다.
- 패키지 다이어그램
  - 요소들을 그룹화한 패키지간의 의존관계를 나타낸다.

### 2. 행위 다이어그램

- 활동 다이어그램
  - 활동 순서의 흐름을 나타낸다.
- 상태 다이어그램
  - 객체가 가진 상태와 상태 변화를 나타낸다.
- 유스케이스 다이어그램
  - 사용자 관점에서 시스템 활동을 나타낸다.
- 순차(시퀀스) 다이어그램
  - 객체들이 주고받는 메시지를 그림으로 나타낸다.
  - 시퀀스 구성항목(액터,객체,생명선,메세지,실행,제어 삼각형)
- 상호작용 다이어그램
  - 상호작용 다이어그램간의 제어 흐름을 나타낸다.
- 통신 다이어그램
  - 동작에 참여하는 객체들의 메세지와 객체들의 연관관계를 나타낸다.
- 타이밍 다이어그램
  - 객체 상태 변화와 시간제약을 명시적으로 나타낸다.

### 3. UML에서 제공하는 클래스 사이의 관계

- 연관관계 : 클래스에서 개념상 서로 연관되어 있음
- 일반화 관계 : 상속 관계를 설명
- 집합 관계
  1. 집약 관계 (Aggregation) : 클래스 사이의 전체 또는 부분 같은 관계를 나타냄 (객체 라이프타임:독립적)
  2. 합성 관계 (Composition) : 클래스 사이의 전체 또는 부분 같은 관계를 나타냄 (객체 라이프타임:의존적)
- 의존 관계 (Dependency) : 연관관계와 같이 한 클래스가 다른클래스에서 제공하는 기능을 사용
- 실체화 관계 (Realization) : 인터페이스와 구현 클래스 사이의 관계를 나타냄

<hr/>

## 요구 분석 (Requirement Analysis)

- 요구 분석의 정의 : 시스템 개발 전 고객의 요구가 무엇인지 확인하고 결정하는 단계

### 1. 요구분석의 2가지 단계

- 분석 단계 : 요구사항을 정의하고 문제 해결 및 구현될 시스템의 목표를 도출하는 단계
- 요구사항 분석의 5가지 종류

  1. 요구 추출 (Requirement Elicitation)

  - 기능적 요구사항: 시스템의 입 출력기능, 데이터베이스의 기능, 통신 기능, 파일 저장 기능, 편집기능, 보기 기능 등으로 직접적으로 제공해야되는 기능을 말한다.

  - 비 기능적 요구사항
    - 성능,사용의 용이성, 신뢰도, 보안성, 안정성 등으로 기능 이외의 품질이나 고려해야 하는 제약사항 등을 말한다.
    - 비 기능적 요구사항의 종류별 특성.
      - 품질 부분 : 사용 용이성, 효율성, 신뢰성,이식성,유연성,확장성,가용성,사용시 오류 발생률 등
      - 안전 부분 : 의도하지 않은 운영으로 인하여 원치 않는 상태에 있는것을 방지하는 역량
      - 성능 부분 : 처리량,응답시간,경과시간,자원사용률
      - 보안 부분 : 침입 대응, 침입 탐지, 사용자 인증, 권한 부여 등
      - 사용성 요구 : 사용자 인터페이스로 하드웨어와 소프트웨어 사이의 인터페이스도 해당한다.

  2. 도메인 분석 (Domain Analysis)

  - 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링함

  3. 모델링 (Modeling)

  - 도메인 분석을 통해 얻은 자료를 개념화한다.

  4. 프로토타이핑과 시험 (Prototyping & testing)

  - 분석된 기능적 요구의 타당성 시험을 위한 프로토타입을 생성하고 테스트한다.

  5. 문서화 및 검토 (Documentation & Validation)

  - 요구 분석서를 작성하고 시스템의 기능, 성능, 정보표현, 제약, 검증 평가 기준에 대하여 검토한다.
  - 요구 명세서 작성단계: 소프트웨어가 어떤 기능을 가져야하는지 작성하는 단계이다.
